# -*- coding:utf-8 -*-
import re
# пример: Адрес Улицы

s = '100 BROAD'
print s
print re.sub('ROAD$', 'RD.', s)
# '100 BRD.'
print re.sub('\\bROAD$', 'RD.', s)   # Требуется совпадения с 'ROAD' когда оно на конце строки и является самостоятельным словом (а не частью большего). Чтобы описать это в регулярном выражении необходимо использовать '\b', что означает «слово должно оказаться прямо тут.» В Python '\' знак в строке должен быть экранирован. Иногда это называют как «бедствие бэкслэша» и это одна из причин почему регулярные выражения проще в Perl чем в Python. Однако недостаток Perl в том что регулярные выражения смешиваются с другим синтаксисом, если у вас ошибка, достаточно сложно определить где она, в синтаксисе или в регулярном выражении.
# '100 BROAD'
print re.sub(r'\bROAD$', 'RD.', s)   # тобы обойти проблему «бедствие бэкслэша» вы можете использовать то, что называется неформатированная строка (raw string), путём применения префикса строки при помощи символа 'r'. Это скажет Python-у что ничего в этой строке не должно быть экранировано; '\t' это табулятор, но r'\t' это символ бэкслэша '\' , а следом за ним буква 't'. 

# '100 BROAD'
s = '100 BROAD ROAD APT. 3'
print s
print re.sub(r'\bROAD$', 'RD.', s)   # В этом случае адрес улицы содержал в себе цельное отдельное слово 'ROAD' и оно не было на конце строки, так как адрес содержал номер квартиры после определения улицы. Так как слово 'ROAD' не находится в конце строки, регулярное выражение re.sub() его пропускало и мы получали на выходе ту же строку что и на входе.

# '100 BROAD ROAD APT. 3'
print re.sub(r'\bROAD\b', 'RD.', s)  # Чтобы решить эту проблему нужно удалить символ '$' и добавить ещё один '\b'. Теперь регулярное выражение совпадает с 'ROAD' если оно являлось цельным словом в любой части строки, на конце, в середине и в начале.
# '100 BROAD RD. APT 3'
